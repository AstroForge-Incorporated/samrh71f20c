#![doc = "Peripheral access API for ATSAMRH71F20C microcontrollers (generated using svd2rust v0.36.1 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.36.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn SUPC();
    fn RSTC();
    fn RTC();
    fn RTT();
    fn WDT();
    fn PMC();
    fn MATRIX0();
    fn FLEXCOM0();
    fn FLEXCOM1();
    fn NMIC();
    fn FLEXCOM2();
    fn FLEXCOM3();
    fn FLEXCOM4();
    fn CCW();
    fn CCF();
    fn FPU();
    fn IXC();
    fn FLEXCOM5();
    fn FLEXCOM6();
    fn FLEXCOM7();
    fn TC0();
    fn TC1();
    fn TC2();
    fn TC3();
    fn TC4();
    fn TC5();
    fn PWM0();
    fn PWM1();
    fn ICM();
    fn MCAN0_INT0();
    fn MCAN0_INT1();
    fn MCAN1_INT0();
    fn MCAN1_INT1();
    fn TCMECC_INTFIX();
    fn TCMECC_INTNOFIX();
    fn FLEXRAMECC_INTFIX();
    fn FLEXRAMECC_INTNOFIX();
    fn SHA();
    fn FLEXCOM8();
    fn FLEXCOM9();
    fn RSWDT();
    fn QSPI();
    fn HEFC_INT0();
    fn HEFC_INTFIX();
    fn HEFC_INTNOFIX();
    fn TC6();
    fn TC7();
    fn TC8();
    fn TC9();
    fn TC10();
    fn TC11();
    fn HEMC_INTSDRAMC();
    fn HEMC_INTFIX();
    fn HEMC_INTNOFIX();
    fn SFR();
    fn TRNG();
    fn XDMAC();
    fn SPW();
    fn IP1553();
    fn GMAC();
    fn GMAC_Q1();
    fn GMAC_Q2();
    fn GMAC_Q3();
    fn GMAC_Q4();
    fn GMAC_Q5();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 75] = [
    Vector { _handler: SUPC },
    Vector { _handler: RSTC },
    Vector { _handler: RTC },
    Vector { _handler: RTT },
    Vector { _handler: WDT },
    Vector { _handler: PMC },
    Vector { _handler: MATRIX0 },
    Vector { _handler: FLEXCOM0 },
    Vector { _handler: FLEXCOM1 },
    Vector { _handler: NMIC },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: FLEXCOM2 },
    Vector { _handler: FLEXCOM3 },
    Vector { _handler: FLEXCOM4 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: CCW },
    Vector { _handler: CCF },
    Vector { _handler: FPU },
    Vector { _handler: IXC },
    Vector { _handler: FLEXCOM5 },
    Vector { _handler: FLEXCOM6 },
    Vector { _handler: FLEXCOM7 },
    Vector { _handler: TC0 },
    Vector { _handler: TC1 },
    Vector { _handler: TC2 },
    Vector { _handler: TC3 },
    Vector { _handler: TC4 },
    Vector { _handler: TC5 },
    Vector { _handler: PWM0 },
    Vector { _handler: PWM1 },
    Vector { _handler: ICM },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector {
        _handler: MCAN0_INT0,
    },
    Vector {
        _handler: MCAN0_INT1,
    },
    Vector {
        _handler: MCAN1_INT0,
    },
    Vector {
        _handler: MCAN1_INT1,
    },
    Vector {
        _handler: TCMECC_INTFIX,
    },
    Vector {
        _handler: TCMECC_INTNOFIX,
    },
    Vector {
        _handler: FLEXRAMECC_INTFIX,
    },
    Vector {
        _handler: FLEXRAMECC_INTNOFIX,
    },
    Vector { _handler: SHA },
    Vector { _handler: FLEXCOM8 },
    Vector { _handler: FLEXCOM9 },
    Vector { _handler: RSWDT },
    Vector { _reserved: 0 },
    Vector { _handler: QSPI },
    Vector {
        _handler: HEFC_INT0,
    },
    Vector {
        _handler: HEFC_INTFIX,
    },
    Vector {
        _handler: HEFC_INTNOFIX,
    },
    Vector { _handler: TC6 },
    Vector { _handler: TC7 },
    Vector { _handler: TC8 },
    Vector { _handler: TC9 },
    Vector { _handler: TC10 },
    Vector { _handler: TC11 },
    Vector {
        _handler: HEMC_INTSDRAMC,
    },
    Vector {
        _handler: HEMC_INTFIX,
    },
    Vector {
        _handler: HEMC_INTNOFIX,
    },
    Vector { _handler: SFR },
    Vector { _handler: TRNG },
    Vector { _handler: XDMAC },
    Vector { _handler: SPW },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: IP1553 },
    Vector { _handler: GMAC },
    Vector { _handler: GMAC_Q1 },
    Vector { _handler: GMAC_Q2 },
    Vector { _handler: GMAC_Q3 },
    Vector { _handler: GMAC_Q4 },
    Vector { _handler: GMAC_Q5 },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - Supply Controller"]
    SUPC = 0,
    #[doc = "1 - Reset Controller"]
    RSTC = 1,
    #[doc = "2 - Real Time Clock"]
    RTC = 2,
    #[doc = "3 - Real Time Timer"]
    RTT = 3,
    #[doc = "4 - Watchdog Timer 0"]
    WDT = 4,
    #[doc = "5 - Power Management Controller"]
    PMC = 5,
    #[doc = "6 - Matrix 0"]
    MATRIX0 = 6,
    #[doc = "7 - FLEXCOM 0"]
    FLEXCOM0 = 7,
    #[doc = "8 - FLEXCOM 1"]
    FLEXCOM1 = 8,
    #[doc = "9 - NMI Controller"]
    NMIC = 9,
    #[doc = "13 - FLEXCOM 2"]
    FLEXCOM2 = 13,
    #[doc = "14 - FLEXCOM 3"]
    FLEXCOM3 = 14,
    #[doc = "15 - FLEXCOM 4"]
    FLEXCOM4 = 15,
    #[doc = "18 - Cache ECC Warning"]
    CCW = 18,
    #[doc = "19 - Cache ECC Fault"]
    CCF = 19,
    #[doc = "20 - Floating Point Unit"]
    FPU = 20,
    #[doc = "21 - Floating Point Unit IXC"]
    IXC = 21,
    #[doc = "22 - FLEXCOM 5"]
    FLEXCOM5 = 22,
    #[doc = "23 - FLEXCOM 6"]
    FLEXCOM6 = 23,
    #[doc = "24 - FLEXCOM 7"]
    FLEXCOM7 = 24,
    #[doc = "25 - Timer/Counter 0"]
    TC0 = 25,
    #[doc = "26 - Timer/Counter 1"]
    TC1 = 26,
    #[doc = "27 - Timer/Counter 2"]
    TC2 = 27,
    #[doc = "28 - Timer/Counter 3"]
    TC3 = 28,
    #[doc = "29 - Timer/Counter 4"]
    TC4 = 29,
    #[doc = "30 - Timer/Counter 5"]
    TC5 = 30,
    #[doc = "31 - Pulse Width Modulation 0"]
    PWM0 = 31,
    #[doc = "32 - Pulse Width Modulation 1"]
    PWM1 = 32,
    #[doc = "33 - Integrity Check Monitor"]
    ICM = 33,
    #[doc = "36 - MCAN Controller 0 Interrupt 0"]
    MCAN0_INT0 = 36,
    #[doc = "37 - MCAN Controller 0 Interrupt 1"]
    MCAN0_INT1 = 37,
    #[doc = "38 - MCAN Controller 1 Interrupt 0"]
    MCAN1_INT0 = 38,
    #[doc = "39 - MCAN Controller 1 Interrupt 1"]
    MCAN1_INT1 = 39,
    #[doc = "40 - TCM ECC Fixable error detected"]
    TCMECC_INTFIX = 40,
    #[doc = "41 - TCM ECC Un-Fixable error detected"]
    TCMECC_INTNOFIX = 41,
    #[doc = "42 - FlexRAM ECC Fixable error detected"]
    FLEXRAMECC_INTFIX = 42,
    #[doc = "43 - FlexRAM ECC Un-Fixable error detected"]
    FLEXRAMECC_INTNOFIX = 43,
    #[doc = "44 - Secure Hash Algorithm"]
    SHA = 44,
    #[doc = "45 - FLEXCOM 8"]
    FLEXCOM8 = 45,
    #[doc = "46 - FLEXCOM 9"]
    FLEXCOM9 = 46,
    #[doc = "47 - Reinforced Secure Watchdog Timer"]
    RSWDT = 47,
    #[doc = "49 - Quad I/O Serial Peripheral Interface"]
    QSPI = 49,
    #[doc = "50 - HEFC Flash Interrupts"]
    HEFC_INT0 = 50,
    #[doc = "51 - HEFC ECC Fixable error detected"]
    HEFC_INTFIX = 51,
    #[doc = "52 - HEFC ECC Un-Fixable error detected"]
    HEFC_INTNOFIX = 52,
    #[doc = "53 - Timer/Counter 6"]
    TC6 = 53,
    #[doc = "54 - Timer/Counter 7"]
    TC7 = 54,
    #[doc = "55 - Timer/Counter 8"]
    TC8 = 55,
    #[doc = "56 - Timer/Counter 9"]
    TC9 = 56,
    #[doc = "57 - Timer/Counter 10"]
    TC10 = 57,
    #[doc = "58 - Timer/Counter 11"]
    TC11 = 58,
    #[doc = "59 - HEMC SDRAM Controller"]
    HEMC_INTSDRAMC = 59,
    #[doc = "60 - HEMC ECC Fixable error detected"]
    HEMC_INTFIX = 60,
    #[doc = "61 - HEMC ECC Un-Fixable error detected"]
    HEMC_INTNOFIX = 61,
    #[doc = "62 - SFR"]
    SFR = 62,
    #[doc = "63 - True Random Generator"]
    TRNG = 63,
    #[doc = "64 - eXtended DMA Controller"]
    XDMAC = 64,
    #[doc = "65 - SpaceWire"]
    SPW = 65,
    #[doc = "68 - MIL 1553"]
    IP1553 = 68,
    #[doc = "69 - Ethernet MAC"]
    GMAC = 69,
    #[doc = "70 - GMAC Queue 1"]
    GMAC_Q1 = 70,
    #[doc = "71 - GMAC Queue 2"]
    GMAC_Q2 = 71,
    #[doc = "72 - GMAC Queue 3"]
    GMAC_Q3 = 72,
    #[doc = "73 - GMAC Queue 4"]
    GMAC_Q4 = 73,
    #[doc = "74 - GMAC Queue 5"]
    GMAC_Q5 = 74,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Chip Identifier"]
pub type Chipid = crate::Periph<chipid::RegisterBlock, 0x4010_0000>;
impl core::fmt::Debug for Chipid {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Chipid").finish()
    }
}
#[doc = "Chip Identifier"]
pub mod chipid;
#[doc = "Flexible Serial Communication"]
pub type Flexcom0 = crate::Periph<flexcom0::RegisterBlock, 0x4001_0000>;
impl core::fmt::Debug for Flexcom0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom0").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub mod flexcom0;
#[doc = "Flexible Serial Communication"]
pub type Flexcom1 = crate::Periph<flexcom0::RegisterBlock, 0x4001_4000>;
impl core::fmt::Debug for Flexcom1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom1").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom1;
#[doc = "Flexible Serial Communication"]
pub type Flexcom2 = crate::Periph<flexcom0::RegisterBlock, 0x4001_8000>;
impl core::fmt::Debug for Flexcom2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom2").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom2;
#[doc = "Flexible Serial Communication"]
pub type Flexcom3 = crate::Periph<flexcom0::RegisterBlock, 0x4001_c000>;
impl core::fmt::Debug for Flexcom3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom3").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom3;
#[doc = "Flexible Serial Communication"]
pub type Flexcom4 = crate::Periph<flexcom0::RegisterBlock, 0x4002_0000>;
impl core::fmt::Debug for Flexcom4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom4").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom4;
#[doc = "Flexible Serial Communication"]
pub type Flexcom5 = crate::Periph<flexcom0::RegisterBlock, 0x4002_4000>;
impl core::fmt::Debug for Flexcom5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom5").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom5;
#[doc = "Flexible Serial Communication"]
pub type Flexcom6 = crate::Periph<flexcom0::RegisterBlock, 0x4002_8000>;
impl core::fmt::Debug for Flexcom6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom6").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom6;
#[doc = "Flexible Serial Communication"]
pub type Flexcom7 = crate::Periph<flexcom0::RegisterBlock, 0x4002_c000>;
impl core::fmt::Debug for Flexcom7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom7").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom7;
#[doc = "Flexible Serial Communication"]
pub type Flexcom8 = crate::Periph<flexcom0::RegisterBlock, 0x4003_0000>;
impl core::fmt::Debug for Flexcom8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom8").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom8;
#[doc = "Flexible Serial Communication"]
pub type Flexcom9 = crate::Periph<flexcom0::RegisterBlock, 0x4003_4000>;
impl core::fmt::Debug for Flexcom9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexcom9").finish()
    }
}
#[doc = "Flexible Serial Communication"]
pub use self::flexcom0 as flexcom9;
#[doc = "FLEXRAMECC"]
pub type Flexramecc = crate::Periph<flexramecc::RegisterBlock, 0x4010_0600>;
impl core::fmt::Debug for Flexramecc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flexramecc").finish()
    }
}
#[doc = "FLEXRAMECC"]
pub mod flexramecc;
#[doc = "Gigabit Ethernet MAC"]
pub type Gmac = crate::Periph<gmac::RegisterBlock, 0x4009_c000>;
impl core::fmt::Debug for Gmac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gmac").finish()
    }
}
#[doc = "Gigabit Ethernet MAC"]
pub mod gmac;
#[doc = "Harden Embedded Flash Controller"]
pub type Hefc = crate::Periph<hefc::RegisterBlock, 0x4000_4000>;
impl core::fmt::Debug for Hefc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hefc").finish()
    }
}
#[doc = "Harden Embedded Flash Controller"]
pub mod hefc;
#[doc = "HEMC"]
pub type Hemc = crate::Periph<hemc::RegisterBlock, 0x4008_0000>;
impl core::fmt::Debug for Hemc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hemc").finish()
    }
}
#[doc = "HEMC"]
pub mod hemc;
#[doc = "Hardened SDRAM Controller"]
pub type Hsdramc = crate::Periph<hsdramc::RegisterBlock, 0x4008_2000>;
impl core::fmt::Debug for Hsdramc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hsdramc").finish()
    }
}
#[doc = "Hardened SDRAM Controller"]
pub mod hsdramc;
#[doc = "Harden Static Memory Controller"]
pub type Hsmc = crate::Periph<hsmc::RegisterBlock, 0x4008_1000>;
impl core::fmt::Debug for Hsmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hsmc").finish()
    }
}
#[doc = "Harden Static Memory Controller"]
pub mod hsmc;
#[doc = "Integrity Check Monitor"]
pub type Icm = crate::Periph<icm::RegisterBlock, 0x4008_c000>;
impl core::fmt::Debug for Icm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Icm").finish()
    }
}
#[doc = "Integrity Check Monitor"]
pub mod icm;
#[doc = "IP 1553"]
pub type Ip1553 = crate::Periph<ip1553::RegisterBlock, 0x4003_c000>;
impl core::fmt::Debug for Ip1553 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ip1553").finish()
    }
}
#[doc = "IP 1553"]
pub mod ip1553;
#[doc = "AHB Bus Matrix"]
pub type Matrix0 = crate::Periph<matrix0::RegisterBlock, 0x4000_0000>;
impl core::fmt::Debug for Matrix0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Matrix0").finish()
    }
}
#[doc = "AHB Bus Matrix"]
pub mod matrix0;
#[doc = "Controller Area Network"]
pub type Mcan0 = crate::Periph<mcan0::RegisterBlock, 0x4005_8000>;
impl core::fmt::Debug for Mcan0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcan0").finish()
    }
}
#[doc = "Controller Area Network"]
pub mod mcan0;
#[doc = "Controller Area Network"]
pub type Mcan1 = crate::Periph<mcan0::RegisterBlock, 0x4005_c000>;
impl core::fmt::Debug for Mcan1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mcan1").finish()
    }
}
#[doc = "Controller Area Network"]
pub use self::mcan0 as mcan1;
#[doc = "Non-maskable Interrupt Controller"]
pub type Nmic = crate::Periph<nmic::RegisterBlock, 0x400a_8000>;
impl core::fmt::Debug for Nmic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Nmic").finish()
    }
}
#[doc = "Non-maskable Interrupt Controller"]
pub mod nmic;
#[doc = "Parallel Input/Output Controller"]
pub type Pio = crate::Periph<pio::RegisterBlock, 0x4000_8000>;
impl core::fmt::Debug for Pio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pio").finish()
    }
}
#[doc = "Parallel Input/Output Controller"]
pub mod pio;
#[doc = "Power Management Controller"]
pub type Pmc = crate::Periph<pmc::RegisterBlock, 0x4000_c000>;
impl core::fmt::Debug for Pmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmc").finish()
    }
}
#[doc = "Power Management Controller"]
pub mod pmc;
#[doc = "Pulse Width Modulation Controller"]
pub type Pwm0 = crate::Periph<pwm0::RegisterBlock, 0x4006_8000>;
impl core::fmt::Debug for Pwm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm0").finish()
    }
}
#[doc = "Pulse Width Modulation Controller"]
pub mod pwm0;
#[doc = "Pulse Width Modulation Controller"]
pub type Pwm1 = crate::Periph<pwm0::RegisterBlock, 0x4006_c000>;
impl core::fmt::Debug for Pwm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm1").finish()
    }
}
#[doc = "Pulse Width Modulation Controller"]
pub use self::pwm0 as pwm1;
#[doc = "Quad Serial Peripheral Interface"]
pub type Qspi = crate::Periph<qspi::RegisterBlock, 0x4003_8000>;
impl core::fmt::Debug for Qspi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Qspi").finish()
    }
}
#[doc = "Quad Serial Peripheral Interface"]
pub mod qspi;
#[doc = "Reset Controller"]
pub type Rstc = crate::Periph<rstc::RegisterBlock, 0x4010_0200>;
impl core::fmt::Debug for Rstc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rstc").finish()
    }
}
#[doc = "Reset Controller"]
pub mod rstc;
#[doc = "Reinforced Safety Watchdog Timer"]
pub type Rswdt = crate::Periph<rswdt::RegisterBlock, 0x4010_0300>;
impl core::fmt::Debug for Rswdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rswdt").finish()
    }
}
#[doc = "Reinforced Safety Watchdog Timer"]
pub mod rswdt;
#[doc = "Real-time Clock"]
pub type Rtc = crate::Periph<rtc::RegisterBlock, 0x4010_0260>;
impl core::fmt::Debug for Rtc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtc").finish()
    }
}
#[doc = "Real-time Clock"]
pub mod rtc;
#[doc = "Real-time Timer"]
pub type Rtt = crate::Periph<rtt::RegisterBlock, 0x4010_0230>;
impl core::fmt::Debug for Rtt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Rtt").finish()
    }
}
#[doc = "Real-time Timer"]
pub mod rtt;
#[doc = "Special Function Registers"]
pub type Sfr = crate::Periph<sfr::RegisterBlock, 0x400a_0000>;
impl core::fmt::Debug for Sfr {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sfr").finish()
    }
}
#[doc = "Special Function Registers"]
pub mod sfr;
#[doc = "Secure Hash Algorithm"]
pub type Sha = crate::Periph<sha::RegisterBlock, 0x4009_4000>;
impl core::fmt::Debug for Sha {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sha").finish()
    }
}
#[doc = "Secure Hash Algorithm"]
pub mod sha;
#[doc = "SpW"]
pub type Spw = crate::Periph<spw::RegisterBlock, 0x4004_0000>;
impl core::fmt::Debug for Spw {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spw").finish()
    }
}
#[doc = "SpW"]
pub mod spw;
#[doc = "Supply Controller"]
pub type Supc = crate::Periph<supc::RegisterBlock, 0x4010_0210>;
impl core::fmt::Debug for Supc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Supc").finish()
    }
}
#[doc = "Supply Controller"]
pub mod supc;
#[doc = "Timer Counter"]
pub type Tc0 = crate::Periph<tc0::RegisterBlock, 0x4007_0000>;
impl core::fmt::Debug for Tc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tc0").finish()
    }
}
#[doc = "Timer Counter"]
pub mod tc0;
#[doc = "Timer Counter"]
pub type Tc1 = crate::Periph<tc0::RegisterBlock, 0x4007_4000>;
impl core::fmt::Debug for Tc1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tc1").finish()
    }
}
#[doc = "Timer Counter"]
pub use self::tc0 as tc1;
#[doc = "Timer Counter"]
pub type Tc2 = crate::Periph<tc0::RegisterBlock, 0x4007_8000>;
impl core::fmt::Debug for Tc2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tc2").finish()
    }
}
#[doc = "Timer Counter"]
pub use self::tc0 as tc2;
#[doc = "Timer Counter"]
pub type Tc3 = crate::Periph<tc0::RegisterBlock, 0x4007_c000>;
impl core::fmt::Debug for Tc3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tc3").finish()
    }
}
#[doc = "Timer Counter"]
pub use self::tc0 as tc3;
#[doc = "HECC"]
pub type Tcmecc = crate::Periph<tcmecc::RegisterBlock, 0x4010_0400>;
impl core::fmt::Debug for Tcmecc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tcmecc").finish()
    }
}
#[doc = "HECC"]
pub mod tcmecc;
#[doc = "True Random Number Generator"]
pub type Trng = crate::Periph<trng::RegisterBlock, 0x4009_0000>;
impl core::fmt::Debug for Trng {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Trng").finish()
    }
}
#[doc = "True Random Number Generator"]
pub mod trng;
#[doc = "Watchdog Timer"]
pub type Wdt = crate::Periph<wdt::RegisterBlock, 0x4010_0250>;
impl core::fmt::Debug for Wdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt").finish()
    }
}
#[doc = "Watchdog Timer"]
pub mod wdt;
#[doc = "Extensible DMA Controller"]
pub type Xdmac = crate::Periph<xdmac::RegisterBlock, 0x4009_8000>;
impl core::fmt::Debug for Xdmac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Xdmac").finish()
    }
}
#[doc = "Extensible DMA Controller"]
pub mod xdmac;
#[doc = "LOCKBIT"]
pub type Lockbit = crate::Periph<lockbit::RegisterBlock, 0>;
impl core::fmt::Debug for Lockbit {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lockbit").finish()
    }
}
#[doc = "LOCKBIT"]
pub mod lockbit;
#[doc = "System control not in SCB"]
pub type ScnScb = crate::Periph<scn_scb::RegisterBlock, 0xe000_e000>;
impl core::fmt::Debug for ScnScb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ScnScb").finish()
    }
}
#[doc = "System control not in SCB"]
pub mod scn_scb;
#[doc = "System timer"]
pub type SysTick = crate::Periph<sys_tick::RegisterBlock, 0xe000_e010>;
impl core::fmt::Debug for SysTick {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SysTick").finish()
    }
}
#[doc = "System timer"]
pub mod sys_tick;
#[doc = "Core Debug Register"]
pub type CoreDebug = crate::Periph<core_debug::RegisterBlock, 0xe000_edf0>;
impl core::fmt::Debug for CoreDebug {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CoreDebug").finish()
    }
}
#[doc = "Core Debug Register"]
pub mod core_debug;
#[doc = "Embedded Trace Macrocell"]
pub type Etm = crate::Periph<etm::RegisterBlock, 0xe004_1000>;
impl core::fmt::Debug for Etm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Etm").finish()
    }
}
#[doc = "Embedded Trace Macrocell"]
pub mod etm;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "CHIPID"]
    pub chipid: Chipid,
    #[doc = "FLEXCOM0"]
    pub flexcom0: Flexcom0,
    #[doc = "FLEXCOM1"]
    pub flexcom1: Flexcom1,
    #[doc = "FLEXCOM2"]
    pub flexcom2: Flexcom2,
    #[doc = "FLEXCOM3"]
    pub flexcom3: Flexcom3,
    #[doc = "FLEXCOM4"]
    pub flexcom4: Flexcom4,
    #[doc = "FLEXCOM5"]
    pub flexcom5: Flexcom5,
    #[doc = "FLEXCOM6"]
    pub flexcom6: Flexcom6,
    #[doc = "FLEXCOM7"]
    pub flexcom7: Flexcom7,
    #[doc = "FLEXCOM8"]
    pub flexcom8: Flexcom8,
    #[doc = "FLEXCOM9"]
    pub flexcom9: Flexcom9,
    #[doc = "FLEXRAMECC"]
    pub flexramecc: Flexramecc,
    #[doc = "GMAC"]
    pub gmac: Gmac,
    #[doc = "HEFC"]
    pub hefc: Hefc,
    #[doc = "HEMC"]
    pub hemc: Hemc,
    #[doc = "HSDRAMC"]
    pub hsdramc: Hsdramc,
    #[doc = "HSMC"]
    pub hsmc: Hsmc,
    #[doc = "ICM"]
    pub icm: Icm,
    #[doc = "IP1553"]
    pub ip1553: Ip1553,
    #[doc = "MATRIX0"]
    pub matrix0: Matrix0,
    #[doc = "MCAN0"]
    pub mcan0: Mcan0,
    #[doc = "MCAN1"]
    pub mcan1: Mcan1,
    #[doc = "NMIC"]
    pub nmic: Nmic,
    #[doc = "PIO"]
    pub pio: Pio,
    #[doc = "PMC"]
    pub pmc: Pmc,
    #[doc = "PWM0"]
    pub pwm0: Pwm0,
    #[doc = "PWM1"]
    pub pwm1: Pwm1,
    #[doc = "QSPI"]
    pub qspi: Qspi,
    #[doc = "RSTC"]
    pub rstc: Rstc,
    #[doc = "RSWDT"]
    pub rswdt: Rswdt,
    #[doc = "RTC"]
    pub rtc: Rtc,
    #[doc = "RTT"]
    pub rtt: Rtt,
    #[doc = "SFR"]
    pub sfr: Sfr,
    #[doc = "SHA"]
    pub sha: Sha,
    #[doc = "SPW"]
    pub spw: Spw,
    #[doc = "SUPC"]
    pub supc: Supc,
    #[doc = "TC0"]
    pub tc0: Tc0,
    #[doc = "TC1"]
    pub tc1: Tc1,
    #[doc = "TC2"]
    pub tc2: Tc2,
    #[doc = "TC3"]
    pub tc3: Tc3,
    #[doc = "TCMECC"]
    pub tcmecc: Tcmecc,
    #[doc = "TRNG"]
    pub trng: Trng,
    #[doc = "WDT"]
    pub wdt: Wdt,
    #[doc = "XDMAC"]
    pub xdmac: Xdmac,
    #[doc = "LOCKBIT"]
    pub lockbit: Lockbit,
    #[doc = "SCnSCB"]
    pub scn_scb: ScnScb,
    #[doc = "SysTick"]
    pub sys_tick: SysTick,
    #[doc = "CoreDebug"]
    pub core_debug: CoreDebug,
    #[doc = "ETM"]
    pub etm: Etm,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            chipid: Chipid::steal(),
            flexcom0: Flexcom0::steal(),
            flexcom1: Flexcom1::steal(),
            flexcom2: Flexcom2::steal(),
            flexcom3: Flexcom3::steal(),
            flexcom4: Flexcom4::steal(),
            flexcom5: Flexcom5::steal(),
            flexcom6: Flexcom6::steal(),
            flexcom7: Flexcom7::steal(),
            flexcom8: Flexcom8::steal(),
            flexcom9: Flexcom9::steal(),
            flexramecc: Flexramecc::steal(),
            gmac: Gmac::steal(),
            hefc: Hefc::steal(),
            hemc: Hemc::steal(),
            hsdramc: Hsdramc::steal(),
            hsmc: Hsmc::steal(),
            icm: Icm::steal(),
            ip1553: Ip1553::steal(),
            matrix0: Matrix0::steal(),
            mcan0: Mcan0::steal(),
            mcan1: Mcan1::steal(),
            nmic: Nmic::steal(),
            pio: Pio::steal(),
            pmc: Pmc::steal(),
            pwm0: Pwm0::steal(),
            pwm1: Pwm1::steal(),
            qspi: Qspi::steal(),
            rstc: Rstc::steal(),
            rswdt: Rswdt::steal(),
            rtc: Rtc::steal(),
            rtt: Rtt::steal(),
            sfr: Sfr::steal(),
            sha: Sha::steal(),
            spw: Spw::steal(),
            supc: Supc::steal(),
            tc0: Tc0::steal(),
            tc1: Tc1::steal(),
            tc2: Tc2::steal(),
            tc3: Tc3::steal(),
            tcmecc: Tcmecc::steal(),
            trng: Trng::steal(),
            wdt: Wdt::steal(),
            xdmac: Xdmac::steal(),
            lockbit: Lockbit::steal(),
            scn_scb: ScnScb::steal(),
            sys_tick: SysTick::steal(),
            core_debug: CoreDebug::steal(),
            etm: Etm::steal(),
        }
    }
}
